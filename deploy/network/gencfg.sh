#!/usr/bin/env bash
# network interfaces config generator with bonded VLAN support
set -euo pipefail

# Find script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="${CONFIG_FILE:-${SCRIPT_DIR}/../config/network.json}"

# Parse options
while getopts ':c:' opt; do
  case "$opt" in
  c) CONFIG_FILE="$OPTARG" ;;
  *)
    echo "Usage: $0 [-c <config-file>] <site>" >&2
    exit 1
    ;;
  esac
done
shift $((OPTIND - 1))

if [[ ! -f "$CONFIG_FILE" ]]; then
  echo "error: config file not found: $CONFIG_FILE" >&2
  exit 1
fi

# validate site argument
readonly SITE="${1:-}"
SITE_UPPER="$(echo "$SITE" | tr '[:lower:]' '[:upper:]')"
if [[ -z "$SITE" ]]; then
  echo "usage: $0 <site>" >&2
  echo "valid sites: $(jq -r '.sites | to_entries[] | select(.value.bgp_local_rr1_v4 != null) | .key' "$CONFIG_FILE" | tr '\n' ' ')" >&2
  exit 1
fi

# validate site exists
if ! jq -e ".sites.$SITE" "$CONFIG_FILE" >/dev/null 2>&1; then
  echo "error: invalid site: $SITE" >&2
  echo "valid sites: $(jq -r '.sites | to_entries[] | select(.value.bgp_local_rr1_v4 != null) | .key' "$CONFIG_FILE" | tr '\n' ' ')" >&2
  exit 1
fi

# Only allow generation for BIRD client sites
SITE_ROLE=$(jq -r ".sites.$SITE.role // \"client\"" "$CONFIG_FILE")
if [[ "$SITE_ROLE" != "client" ]] && [[ -z "$(jq -r ".sites.$SITE.bgp_local_rr1_v4 // empty" "$CONFIG_FILE")" ]]; then
  echo "error: site $SITE is not a BIRD client (role: $SITE_ROLE)" >&2
  echo "this generator only works for sites with BGP configuration" >&2
  exit 1
fi

# extract site config
SITE_CONFIG=$(jq -r ".sites.$SITE" "$CONFIG_FILE")
SITE_NUM="${SITE#bkk}"   # extract number from site name
SITE_NUM="${SITE_NUM#0}" # remove leading zero if present

# extract configuration values
ROUTER_ID=$(echo "$SITE_CONFIG" | jq -r '.router_id')
MANAGEMENT_IP=$(echo "$SITE_CONFIG" | jq -r '.management')
MANAGEMENT_GW=$(echo "$SITE_CONFIG" | jq -r '.management_gateway // empty')
MANAGEMENT_V6=$(echo "$SITE_CONFIG" | jq -r '.management_v6 // empty')
MANAGEMENT_V6_GW=$(echo "$SITE_CONFIG" | jq -r '.management_v6_gateway // empty')
PUBLIC_V4=$(echo "$SITE_CONFIG" | jq -r '.public_v4')
PUBLIC_V6=$(echo "$SITE_CONFIG" | jq -r '.public_v6')
INTERNAL_V4=$(echo "$SITE_CONFIG" | jq -r '.internal_v4')
INTERNAL_V6=$(echo "$SITE_CONFIG" | jq -r '.internal_v6')

# BGP addresses
BGP_RR1_V4=$(echo "$SITE_CONFIG" | jq -r '.bgp_local_rr1_v4')
BGP_RR1_V6=$(echo "$SITE_CONFIG" | jq -r '.bgp_local_rr1_v6')
BGP_RR2_V4=$(echo "$SITE_CONFIG" | jq -r '.bgp_local_rr2_v4')
BGP_RR2_V6=$(echo "$SITE_CONFIG" | jq -r '.bgp_local_rr2_v6')

# route reflector gateways
RR1_GW_V4=$(jq -r --arg site "$SITE_UPPER" '.route_reflectors.rr1[$site].v4' "$CONFIG_FILE")
RR2_GW_V4=$(jq -r --arg site "$SITE_UPPER" '.route_reflectors.rr2[$site].v4' "$CONFIG_FILE")
RR1_GW_V6=$(jq -r --arg site "$SITE_UPPER" '.route_reflectors.rr1[$site].v6' "$CONFIG_FILE")
RR2_GW_V6=$(jq -r --arg site "$SITE_UPPER" '.route_reflectors.rr2[$site].v6' "$CONFIG_FILE")

# anycast addresses
ANYCAST_LOCAL_V4=$(echo "$SITE_CONFIG" | jq -r '.anycast_local_v4 // empty' | sed 's|/32||')
ANYCAST_LOCAL_V6=$(echo "$SITE_CONFIG" | jq -r '.anycast_local_v6 // empty' | sed 's|/128||')
ANYCAST_GLOBAL_V4=$(echo "$SITE_CONFIG" | jq -r '.anycast_global_v4 // empty' | sed 's|/32||')
ANYCAST_GLOBAL_V6=$(echo "$SITE_CONFIG" | jq -r '.anycast_global_v6 // empty' | sed 's|/128||')

# physical interfaces
MGMT_IFACE=$(echo "$SITE_CONFIG" | jq -r '.physical_interfaces.management // "eno2"')
BOND_MEMBERS=$(echo "$SITE_CONFIG" | jq -r '.physical_interfaces.bond_members[]?' 2>/dev/null | tr '\n' ' ')
UNUSED_IFACES=$(echo "$SITE_CONFIG" | jq -r '.physical_interfaces.unused[]?' 2>/dev/null | tr '\n' ' ')
BONDED_VLANS=$(echo "$SITE_CONFIG" | jq -r '.physical_interfaces.bonded_vlans // false')

# global settings
MGMT_GATEWAY="${MANAGEMENT_GW:-$(jq -r '.networks.management_gateway // "192.168.69.1"' "$CONFIG_FILE")}"
QINQ_OUTER=$(jq -r '.networks.qinq_outer // 400' "$CONFIG_FILE")

# bond configuration
BOND_MODE=$(jq -r '.bond_config.mode // "802.3ad"' "$CONFIG_FILE")
BOND_MIIMON=$(jq -r '.bond_config.miimon // 100' "$CONFIG_FILE")
BOND_LACP_RATE=$(jq -r '.bond_config.lacp_rate // "fast"' "$CONFIG_FILE")
BOND_MTU=$(jq -r '.bond_config.mtu // 9000' "$CONFIG_FILE")

# VLAN IDs based on site number (pad to 2 digits)
VLAN_RR1_DIRECT="1$(printf "%02d" "$SITE_NUM")"
VLAN_RR2_DIRECT="2$(printf "%02d" "$SITE_NUM")"
VLAN_RR1_VIA_BKK10="11${SITE_NUM}"
VLAN_RR2_VIA_BKK10="21${SITE_NUM}"

# fix IPv6 addresses to ensure no extra colons
INTERNAL_V6_PREFIX="${INTERNAL_V6%%/*}"
while [[ "$INTERNAL_V6_PREFIX" == *: ]]; do
  INTERNAL_V6_PREFIX="${INTERNAL_V6_PREFIX%:}"
done

# generate interfaces configuration
generate_interfaces() {
  cat <<INTERFACES
# /etc/network/interfaces for ${SITE}
# Generated by $0 on $(date -u +"%Y-%m-%d %H:%M:%S UTC")
#
# Routing table structure:
#   Table 100 (public)    - All public traffic (unicast + anycast)
#   Table 101 (internal)  - Internal services traffic
#   Table 102 (mgmt)      - Management traffic
#   Table 103 (anycast-local)  - Local anycast (optional, future use)
#   Table 104 (anycast-global) - Global anycast (optional, future use)
#
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# Create routing tables on boot
auto lo
iface lo inet loopback
    # Create all routing tables
    up echo "100 public" >> /etc/iproute2/rt_tables 2>/dev/null || true
    up echo "101 internal" >> /etc/iproute2/rt_tables 2>/dev/null || true
    up echo "102 mgmt" >> /etc/iproute2/rt_tables 2>/dev/null || true
    up echo "103 anycast-local" >> /etc/iproute2/rt_tables 2>/dev/null || true
    up echo "104 anycast-global" >> /etc/iproute2/rt_tables 2>/dev/null || true
    # router ID
    up ip addr add ${ROUTER_ID}/32 dev lo
    # public IPv4
    up ip addr add ${PUBLIC_V4}/32 dev lo
INTERFACES

  # add anycast IPs if present
  if [[ -n "$ANYCAST_LOCAL_V4" ]]; then
    echo "    # anycast local IPs"
    echo "    up ip addr add ${ANYCAST_LOCAL_V4}/32 dev lo"
  fi
  if [[ -n "$ANYCAST_GLOBAL_V4" ]]; then
    echo "    # anycast global IPs"
    echo "    up ip addr add ${ANYCAST_GLOBAL_V4}/32 dev lo"
  fi

  cat <<INTERFACES

iface lo inet6 loopback
    # router ID
    up ip -6 addr add fd00:155:255::${SITE_NUM}/128 dev lo
    # public IPv6
    up ip -6 addr add ${PUBLIC_V6}/128 dev lo
INTERFACES

  # add IPv6 anycast if present
  if [[ -n "$ANYCAST_LOCAL_V6" ]]; then
    echo "    # anycast local IPv6"
    echo "    up ip -6 addr add ${ANYCAST_LOCAL_V6}/128 dev lo"
  fi
  if [[ -n "$ANYCAST_GLOBAL_V6" ]]; then
    echo "    # anycast global IPv6"
    echo "    up ip -6 addr add ${ANYCAST_GLOBAL_V6}/128 dev lo"
  fi

  cat <<INTERFACES

# physical interfaces
iface ${MGMT_IFACE} inet manual
iface ${MGMT_IFACE} inet6 manual

# management bridge
auto vmbr0
iface vmbr0 inet static
    address ${MANAGEMENT_IP%%/*}
    netmask 255.255.0.0
    gateway ${MGMT_GATEWAY}
    bridge-ports ${MGMT_IFACE}
    bridge-stp off
    bridge-fd 0
    # Management routing policy
    post-up ip route add default via ${MGMT_GATEWAY} dev vmbr0 table mgmt
    post-up ip rule add from ${MANAGEMENT_IP%%/*} table mgmt priority 300
    post-up ip rule add iif vmbr0 table mgmt priority 310
    pre-down ip rule del from ${MANAGEMENT_IP%%/*} table mgmt 2>/dev/null || true
    pre-down ip rule del iif vmbr0 table mgmt 2>/dev/null || true
    pre-down ip route flush table mgmt 2>/dev/null || true
INTERFACES

  # add IPv6 to vmbr0 if present
  if [[ -n "$MANAGEMENT_V6" ]]; then
    cat <<VMBR0_V6

iface vmbr0 inet6 static
    address ${MANAGEMENT_V6}
    gateway ${MANAGEMENT_V6_GW}
    pre-up echo 0 > /proc/sys/net/ipv6/conf/vmbr0/accept_ra
    pre-up echo 0 > /proc/sys/net/ipv6/conf/vmbr0/autoconf
    accept_ra 0
    autoconf 0
    # Management routing policy for IPv6
    post-up ip -6 route add default via ${MANAGEMENT_V6_GW} dev vmbr0 table mgmt
    post-up ip -6 rule add from ${MANAGEMENT_V6} table mgmt priority 300
    post-up ip -6 rule add iif vmbr0 table mgmt priority 310
    pre-down ip -6 rule del from ${MANAGEMENT_V6} table mgmt 2>/dev/null || true
    pre-down ip -6 rule del iif vmbr0 table mgmt 2>/dev/null || true
    pre-down ip -6 route flush table mgmt 2>/dev/null || true
VMBR0_V6
  fi

  # Check if using bonded VLANs (new design)
  if [[ "$BONDED_VLANS" == "true" ]]; then
    # Split uplink configuration
    UPLINK1=$(echo "$BOND_MEMBERS" | awk '{print $1}')
    UPLINK2=$(echo "$BOND_MEMBERS" | awk '{print $2}')
    UP1_BASE="100$(printf '%s' "$UPLINK1" | sed 's/^.*\(..\)$/\1/')"
    UP2_BASE=$(printf "%s" "$UPLINK2" | sed 's/^.*\(.\{5\}\)$/\1/')

    cat <<BONDED_CONFIG

# physical interfaces for split uplinks
iface ${UPLINK1} inet manual
    mtu ${BOND_MTU}

iface ${UPLINK2} inet manual
    mtu ${BOND_MTU}

# unused interfaces
BONDED_CONFIG

    for iface in $UNUSED_IFACES; do
      echo "iface $iface inet manual"
    done

    cat <<BONDED_CONFIG

# VLAN 400 on each physical interface
auto ${UP1_BASE}.${QINQ_OUTER}
iface ${UP1_BASE}.${QINQ_OUTER} inet manual
    vlan-raw-device ${UPLINK1}
    vlan-id ${QINQ_OUTER}
    mtu ${BOND_MTU}

auto ${UP2_BASE}.${QINQ_OUTER}
iface ${UP2_BASE}.${QINQ_OUTER} inet manual
    vlan-raw-device ${UPLINK2}
    vlan-id ${QINQ_OUTER}
    mtu ${BOND_MTU}

# Q-in-Q inner VLANs on first interface (via bkk30)
auto vlan${VLAN_RR1_DIRECT}
iface vlan${VLAN_RR1_DIRECT} inet manual
    vlan-raw-device ${UP1_BASE}.${QINQ_OUTER}
    vlan-id ${VLAN_RR1_DIRECT}
    mtu 1500

auto vlan${VLAN_RR2_DIRECT}
iface vlan${VLAN_RR2_DIRECT} inet manual
    vlan-raw-device ${UP1_BASE}.${QINQ_OUTER}
    vlan-id ${VLAN_RR2_DIRECT}
    mtu 1500

# Q-in-Q inner VLANs on second interface (via bkk10)
auto vlan${VLAN_RR1_VIA_BKK10}
iface vlan${VLAN_RR1_VIA_BKK10} inet manual
    vlan-raw-device ${UP2_BASE}.${QINQ_OUTER}
    vlan-id ${VLAN_RR1_VIA_BKK10}
    mtu 1500

auto vlan${VLAN_RR2_VIA_BKK10}
iface vlan${VLAN_RR2_VIA_BKK10} inet manual
    vlan-raw-device ${UP2_BASE}.${QINQ_OUTER}
    vlan-id ${VLAN_RR2_VIA_BKK10}
    mtu 1500

# Bond to bkk00 (direct + via bkk10)
auto bond-bkk00
iface bond-bkk00 inet manual
    bond-slaves vlan${VLAN_RR1_DIRECT} vlan${VLAN_RR1_VIA_BKK10}
    bond-mode ${BOND_MODE}
    bond-primary vlan${VLAN_RR1_DIRECT}
    bond-miimon ${BOND_MIIMON}
    bond-lacp-rate ${BOND_LACP_RATE}
    bond-xmit-hash-policy layer3+4
    mtu 1500

# Bond to bkk20 (direct + via bkk10)
auto bond-bkk20
iface bond-bkk20 inet manual
    bond-slaves vlan${VLAN_RR2_DIRECT} vlan${VLAN_RR2_VIA_BKK10}
    bond-mode ${BOND_MODE}
    bond-primary vlan${VLAN_RR2_DIRECT}
    bond-miimon ${BOND_MIIMON}
    bond-lacp-rate ${BOND_LACP_RATE}
    bond-xmit-hash-policy layer3+4
    mtu 1500
BONDED_CONFIG

  else
    # Traditional single bond configuration
    cat <<TRADITIONAL_CONFIG

# physical interfaces for bonding
TRADITIONAL_CONFIG

    for iface in $BOND_MEMBERS; do
      echo "iface $iface inet manual"
    done

    if [[ -n "$UNUSED_IFACES" ]]; then
      echo ""
      echo "# unused interfaces"
      for iface in $UNUSED_IFACES; do
        echo "iface $iface inet manual"
      done
    fi

    cat <<TRADITIONAL_CONFIG

# LACP bond of both trunks
auto bond0
iface bond0 inet manual
    bond-slaves ${BOND_MEMBERS}
    bond-mode ${BOND_MODE}
    bond-miimon ${BOND_MIIMON}
    bond-lacp-rate ${BOND_LACP_RATE}
    mtu ${BOND_MTU}

# Q-in-Q outer VLAN ${QINQ_OUTER} on the bond
auto bond0.${QINQ_OUTER}
iface bond0.${QINQ_OUTER} inet manual
    vlan-raw-device bond0
    vlan-id ${QINQ_OUTER}
    mtu ${BOND_MTU}

# Q-in-Q inner VLAN ${VLAN_RR1_DIRECT} (to bkk00/rr1)
auto vlan${VLAN_RR1_DIRECT}
iface vlan${VLAN_RR1_DIRECT} inet manual
    vlan-raw-device bond0.${QINQ_OUTER}
    vlan-id ${VLAN_RR1_DIRECT}
    mtu ${BOND_MTU}

# Q-in-Q inner VLAN ${VLAN_RR2_DIRECT} (to bkk20/rr2)
auto vlan${VLAN_RR2_DIRECT}
iface vlan${VLAN_RR2_DIRECT} inet manual
    vlan-raw-device bond0.${QINQ_OUTER}
    vlan-id ${VLAN_RR2_DIRECT}
    mtu ${BOND_MTU}
TRADITIONAL_CONFIG
  fi

  # Common configuration for both designs
  cat <<COMMON_CONFIG

# internal services bridge
auto vmbr1
iface vmbr1 inet static
    address 10.${SITE_NUM}.0.1
    netmask 255.255.0.0
    bridge-ports none
    bridge-stp off
    bridge-fd 0
    # Internal services routing policy
    post-up ip route add 10.0.0.0/8 via 10.${SITE_NUM}.0.1 dev vmbr1 table internal
    post-up ip route add 172.16.0.0/12 via 10.${SITE_NUM}.0.1 dev vmbr1 table internal
    post-up ip route add 192.168.0.0/16 via 10.${SITE_NUM}.0.1 dev vmbr1 table internal
    post-up ip rule add from 10.${SITE_NUM}.0.0/16 table internal priority 200
    post-up ip rule add iif vmbr1 table internal priority 210
    pre-down ip rule del from 10.${SITE_NUM}.0.0/16 table internal 2>/dev/null || true
    pre-down ip rule del iif vmbr1 table internal 2>/dev/null || true
    pre-down ip route flush table internal 2>/dev/null || true

iface vmbr1 inet6 static
    address ${INTERNAL_V6_PREFIX}::1/48
    accept_ra 0
    autoconf 0
    # Internal services routing policy for IPv6
    post-up ip -6 route add fd00::/8 via ${INTERNAL_V6_PREFIX}::1 dev vmbr1 table internal
    post-up ip -6 route add fe80::/10 via ${INTERNAL_V6_PREFIX}::1 dev vmbr1 table internal
    post-up ip -6 rule add from ${INTERNAL_V6_PREFIX}::/48 table internal priority 200
    post-up ip -6 rule add iif vmbr1 table internal priority 210
    pre-down ip -6 rule del from ${INTERNAL_V6_PREFIX}::/48 table internal 2>/dev/null || true
    pre-down ip -6 rule del iif vmbr1 table internal 2>/dev/null || true
    pre-down ip -6 route flush table internal 2>/dev/null || true

# public services bridge
auto vmbr2
iface vmbr2 inet static
COMMON_CONFIG

  if [[ "$BONDED_VLANS" == "true" ]]; then
    echo "    bridge-ports bond-bkk00 bond-bkk20"
  else
    echo "    bridge-ports vlan${VLAN_RR2_DIRECT} vlan${VLAN_RR1_DIRECT}"
  fi

  cat <<COMMON_CONFIG
    bridge-stp off
    bridge-fd 0
    address ${BGP_RR1_V4}/31
    address ${BGP_RR2_V4}/31
    mtu 1500
    # Public services routing policy with ECMP
    # All public traffic uses table 100 (public)
    post-up ip route add default table public nexthop via ${RR1_GW_V4} dev vmbr2 weight 1 nexthop via ${RR2_GW_V4} dev vmbr2 weight 1
    # Source-based rules for public IPs (priority 100-109)
    post-up ip rule add from ${PUBLIC_V4} table public priority 100
COMMON_CONFIG

  if [[ -n "$ANYCAST_LOCAL_V4" ]]; then
    echo "    post-up ip rule add from ${ANYCAST_LOCAL_V4} table public priority 101"
  fi
  if [[ -n "$ANYCAST_GLOBAL_V4" ]]; then
    echo "    post-up ip rule add from ${ANYCAST_GLOBAL_V4} table public priority 102"
  fi

  cat <<COMMON_CONFIG
    # Critical: route return traffic via incoming interface
    post-up ip rule add iif vmbr2 table public priority 150
    # Cleanup rules on interface down
    pre-down ip rule del from ${PUBLIC_V4} table public 2>/dev/null || true
COMMON_CONFIG

  if [[ -n "$ANYCAST_LOCAL_V4" ]]; then
    echo "    pre-down ip rule del from ${ANYCAST_LOCAL_V4} table public 2>/dev/null || true"
  fi
  if [[ -n "$ANYCAST_GLOBAL_V4" ]]; then
    echo "    pre-down ip rule del from ${ANYCAST_GLOBAL_V4} table public 2>/dev/null || true"
  fi

  cat <<COMMON_CONFIG
    pre-down ip rule del iif vmbr2 table public 2>/dev/null || true
    pre-down ip route flush table public 2>/dev/null || true

iface vmbr2 inet6 static
    address ${BGP_RR1_V6}/127
    address ${BGP_RR2_V6}/127
    accept_ra 0
    autoconf 0
COMMON_CONFIG

  # Add IPv6 policy-based routing with ECMP
  RR1_GW_V6_CLEAN="${RR1_GW_V6%::0}"
  RR2_GW_V6_CLEAN="${RR2_GW_V6%::0}"
  [[ "$RR1_GW_V6_CLEAN" != *:: ]] && RR1_GW_V6_CLEAN="${RR1_GW_V6_CLEAN}::"
  [[ "$RR2_GW_V6_CLEAN" != *:: ]] && RR2_GW_V6_CLEAN="${RR2_GW_V6_CLEAN}::"

  cat <<POLICY_V6
    # Public services routing policy for IPv6 with ECMP
    post-up ip -6 route add default table public nexthop via ${RR1_GW_V6_CLEAN} dev vmbr2 weight 1 nexthop via ${RR2_GW_V6_CLEAN} dev vmbr2 weight 1
    # Source-based rules for public IPv6 (priority 100-109)
    post-up ip -6 rule add from ${PUBLIC_V6} table public priority 100
POLICY_V6

  if [[ -n "$ANYCAST_LOCAL_V6" ]]; then
    echo "    post-up ip -6 rule add from ${ANYCAST_LOCAL_V6} table public priority 101"
  fi
  if [[ -n "$ANYCAST_GLOBAL_V6" ]]; then
    echo "    post-up ip -6 rule add from ${ANYCAST_GLOBAL_V6} table public priority 102"
  fi

  cat <<POLICY_V6
    # Critical: route return traffic via incoming interface
    post-up ip -6 rule add iif vmbr2 table public priority 150
    # Cleanup rules on interface down
    pre-down ip -6 rule del from ${PUBLIC_V6} table public 2>/dev/null || true
POLICY_V6

  if [[ -n "$ANYCAST_LOCAL_V6" ]]; then
    echo "    pre-down ip -6 rule del from ${ANYCAST_LOCAL_V6} table public 2>/dev/null || true"
  fi
  if [[ -n "$ANYCAST_GLOBAL_V6" ]]; then
    echo "    pre-down ip -6 rule del from ${ANYCAST_GLOBAL_V6} table public 2>/dev/null || true"
  fi

  cat <<POLICY_V6
    pre-down ip -6 rule del iif vmbr2 table public 2>/dev/null || true
    pre-down ip -6 route flush table public 2>/dev/null || true
POLICY_V6
}

# main execution
generate_interfaces
